/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Keyboard Events
 #	author : miyako
 #	2016/09/05
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

namespace Keyboard
{
	C_TEXT methodName;
	method_id_t methodId = 0;
	
	BOOL isMonitoring = false;
	BOOL shouldKillListenerLoop = false;
	
	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0K\0E\0Y\0D\0O\0W\0N\0\0\0";
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
	process_number_t monitorProcessId = 0;
	process_number_t userProcessId = 0;
	
	std::vector<UInt32>keycodes;
	std::vector<char>keychars;
	
	EventTypeSpec	events[] =
	{
		{kEventClassKeyboard, kEventRawKeyDown}
	};
	
	EventHandlerRef	eventHandlerRef;
	
	static OSStatus myKeyboardEventHander(EventHandlerCallRef inCaller,
																				EventRef inEvent,
																				void *inUserData)
	{

		if(GetEventClass(inEvent) == kEventClassKeyboard)
			if(GetEventKind(inEvent) == kEventRawKeyDown)
			{
				UInt32 keyCode;
				char keyChar;
				
				if(noErr == GetEventParameter(inEvent, kEventParamKeyCode, typeUInt32,
																			NULL, sizeof(UInt32),
																			NULL, &keyCode))
				{
					if(noErr == GetEventParameter(inEvent, kEventParamKeyMacCharCodes, typeChar,
																				NULL, sizeof(char),
																				NULL, &keyChar))
					{
						keycodes.push_back(keyCode);
						keychars.push_back(keyChar);
						
						NSLog(@"%u,%u", (unsigned int)keyCode, keyChar);
					}
				}
			}
		
		if(monitorProcessId)
			PA_UnfreezeProcess(monitorProcessId);
		
		return eventNotHandledErr;
	}
	
	void startMonitoring()
	{
		if(!isMonitoring)
		{
			EventHandlerUPP eventHandlerUpp = NewEventHandlerUPP(myKeyboardEventHander);
			
			if(noErr == InstallEventHandler(GetApplicationEventTarget(),
													eventHandlerUpp,
													GetEventTypeCount(events),
																			events, 0, &eventHandlerRef)) isMonitoring = true;
			
			DisposeEventHandlerUPP(eventHandlerUpp);
		}
		
		if(isMonitoring)
		{
			if(!monitorProcessId)
			{
				monitorProcessId = PA_NewProcess((void *)listenerLoop, MONITOR_PROCESS_STACK_SIZE, MONITOR_PROCESS_NAME);
			}
		}
	}
	
	void stopMonitoring()
	{
		if(isMonitoring)
		{
			RemoveEventHandler(eventHandlerRef);
			isMonitoring = false;
		}
		if(monitorProcessId)
		{
			shouldKillListenerLoop = true;
			while(monitorProcessId)
			{
				PA_YieldAbsolute();
				PA_UnfreezeProcess(monitorProcessId);
			}
		}
	}
	
	void init()
	{
		keycodes.clear();
		keychars.clear();
	}
	
	void callMethod()
	{
		std::vector<UInt32>::iterator a = keycodes.begin();
		std::vector<char>::iterator b = keychars.begin();
		
		UInt32 keycode = *a;
		char keychar = *b;
	
		if(methodId)
		{
			PA_Variable	params[3];
			params[0] = PA_CreateVariable(eVK_Longint);
			PA_SetLongintVariable(&params[0], keycode);
			
			char buf[2];
			buf[0] = keychar;
			buf[1] = 0;
			C_TEXT u;
			u.setUTF8String((const uint8_t *)buf, 1);
			params[1] = PA_CreateVariable(eVK_Unistring);
			PA_Unistring keycharStr = PA_CreateUnistring((PA_Unichar *)u.getUTF16StringPtr());
			PA_SetStringVariable(&params[1], &keycharStr);
			
			params[2] = PA_CreateVariable(eVK_Longint);
			PA_SetLongintVariable(&params[2], userProcessId);
			
			keycodes.erase(a);
			keychars.erase(b);
			
			PA_ExecuteMethodByID(methodId, params, 3);
			
			PA_ClearVariable(&params[0]);
			PA_ClearVariable(&params[1]);
			PA_ClearVariable(&params[2]);
		}
/*		else if(methodName.getUTF16Length())
		{
			PA_Variable	params[5];
			params[0] = PA_CreateVariable(eVK_Unistring);
			PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)methodName.getUTF16StringPtr());
			PA_SetStringVariable(&params[0], &_methodName);
			
			PA_SetOperationVariable(&params[1], '*');
			
			params[2] = PA_CreateVariable(eVK_Longint);
			PA_SetLongintVariable(&params[2], keycode);
			
			char buf[2];
			buf[0] = keychar;
			buf[1] = 0;
			C_TEXT u;
			u.setUTF8String((const uint8_t *)buf, 1);
			params[1] = PA_CreateVariable(eVK_Unistring);
			PA_Unistring keycharStr = PA_CreateUnistring((PA_Unichar *)u.getUTF16StringPtr());
			PA_SetStringVariable(&params[3], &keycharStr);
			
			params[4] = PA_CreateVariable(eVK_Longint);
			PA_SetLongintVariable(&params[4], userProcessId);
			
			keycodes.erase(a);
			keychars.erase(b);
			
			PA_ExecuteCommandByID(1007, params, 5);
			
			PA_ClearVariable(&params[0]);
			PA_ClearVariable(&params[1]);
			PA_ClearVariable(&params[3]);
			PA_ClearVariable(&params[4]);
		} */
		else
		{
			keycodes.clear();
			keychars.clear();
		}
	}
}

#pragma mark -

void listenerLoop()
{
	Keyboard::shouldKillListenerLoop = false;
	Keyboard::init();
	
	while(!Keyboard::shouldKillListenerLoop)
	{
		PA_YieldAbsolute();
		while(Keyboard::keycodes.size())
		{
			PA_YieldAbsolute();
			
			Keyboard::callMethod();
			
			if(Keyboard::shouldKillListenerLoop)
				break;
		}
		
		if(!Keyboard::shouldKillListenerLoop)
		{
			PA_FreezeProcess(PA_GetCurrentProcessNumber());
		}
	}
	
	Keyboard::monitorProcessId = 0;
	
	PA_KillProcess();
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
//	Keyboard::startMonitoring();
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		Keyboard::stopMonitoring();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
// --- Keyboard

		case 1 :
			ON_RAW_KEYDOWN_CALL(pResult, pParams);
			break;

	}
}

// ----------------------------------- Keyboard -----------------------------------


void ON_RAW_KEYDOWN_CALL(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	Keyboard::methodName.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
	Keyboard::methodId = PA_GetMethodID((PA_Unichar *)Param1.getUTF16StringPtr());
	Keyboard::userProcessId = Param2.getIntValue();
	
	if(Param1.getUTF16Length())
	{
		Keyboard::startMonitoring();
	}else{
		Keyboard::stopMonitoring();
	}
}